---
layout: post
title:  "Deadlock"
date:   2016-11-25 15:00:00 +0000
description:
tags: ['Deadlock', 'OS']
author: "AngJoong"
---

다중프로그램이 환경에서는 여러 프로세스들이 한정된 자원을 사용하려고 서로 경쟁 한다. 대기중인 프로세스들이 그 상태를 결코 변경시킬 수 없을때 교착상태라 부른다.  

# 1. 시스템 모델 (System Model)
시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 수의 자원들로 구성된다. 프로세스는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다. 정상적인 경우에 프로세스는 다음 순서로만 자원을 사용할 수 있다.  

1. 요청: 요청이 즉시 허용되지 않으면, 요청 프로세스는 자원을 얻을 때가지 대기한다.
2. 사용: 자원에 대한 작업을 실행한다.
3. 방출: 자원을 방출한다.  

프로세스나 스레드가 커널이 관리하는 자원을 사용할 때마다 매번 운영체제는 프로세스가 자원을 요청했는지와 그 자원을 할당받았는지를 확인한다. 시스템 테이블이 각 자원이 자유 상태인지 할당되었는지 기록하고 어느 프로세스에 할당되었는지 기록한다. 프로세스가 이미 할당된 자원을 요청하면, 그 자원을 기다리는 프로세스 큐에 넣는다.  

# 2. 교착상태의 특징 (Deadlock Characterization)
교착상태에 빠진 프로세스들은 결코 실행을 끝낼 수 없으며, 자원이 묶여 있어 다른 작업을 시작하지도 못한다.  

# 2.1 필요 조건들 (Necessary Conditions)
교착상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생한다.

## 1. 상호 배제 (mutual exclusion)
최소한 하나의 자원이 비공유 모드로 점유되어야 한다. 비공유 모드에서는 한번에 한 프로세스만 자원을 사용할 수 있어, 자원이 방출될 때까지 다른 프로세스는 지연된다.

## 2. 점유 대기 (hold-and-wait)
최소한 하나의 자원을 점유한 채, 다른 프로세스에 의해 점유된 자원으 추가로 얻기 위해 대기한다.  

## 3. 비선점 (no preemption)
자원을 선점할 수 없다. 자원이 강제적으로 방출될 수 없고, 점유하고 있는 프로세스에 의해 자발적으로만 방출될 수 있다.  

## 4. 순환 대기 (circular wait)
대기하고 있는 프로세스의 집합 {P<sub>0</sub>, ..., P<sub>n</sub>}에서 P<sub>0</sub>는 P<sub>1</sub>의 점유 자원을 대기하고 P<sub>1</sub>는 P<sub>2</sub>의 자원을 대기하고 마지막 P<sub>n</sub>은 P<sub>0</sub>의 자원을 대기한다.  

각 조건이 완전히 독립적인 것은 아니지만 네 조건이 모두 성립되어야 교착상태가 발생한다.  

## 2.2 자원 할당 그래프 (Resource-Allocation Graph)
교착상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 보다 정확하게 기술할 수 있다.

###### &lt;자원 할당 그래프: 원-프로세스, 사각형-리소스, 점-리소스 개수, 간선-점유 관계>
![](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter7/7_01_ResourceAllocation.jpg)

그래프가 사이클을 포함하지 않으면 시스템 내 어느 프로세스도 교착상태가 아니다. 각 자원 타입이 정확하게 하나의 인스턴스만을 가지면, 하나의 사이클은 교착상태가 발생하였음을 암시한다. 자원 타입이 여러개의 인스턴스를 가지면 사이클은 필요 조건이지 충분조건은 되지 못한다.  

# 3. 교착상태 처리 방법 (Methods for Handling Deadlock)
원칙적으로 교착상태 문제를 처리하는 세 가지 방법이 있다.  

* 교착상태를 예방하거나 회피한다.
* 교착상태를 허용하나 회복시키는 방법을 가진다.
* 교착상태 문제를 무시하고 결코 발생하지 않는 척 한다.  

대부분 운영체제에서 세 번째 해결안을 사용하고 있으며 교착상태의 처리는 응용 개발자의 몫으로 한다. 교착상태를 처리하는 기본적인 방법 중 단독으로는 자원 할당 문제 전 범위를 해결하기는 힘들다. 문제 각각에 최적인 해결책을 선택하는데 기본적인 방법들을 조합하여 사용한다.  

# 4. 교착상태 예방 (Deadlock Prevention)
교착 상태가 발생하려면 네 가지의 필요조건이 반드시 성립해야 한다. 이 조건중 최소 하나가 성립하지 않음을 보장함으로써 교착상태를 예방한다.

## 1. 상호 배제 예방
자원들을 공유 가능하게 만든다. 프로세스는 자원을 위해 대기할 필요가 없어진다. 그러나 어떤 자원들은 근본적으로 공유가 불가능하기때문에 상호 배제 예방은 불가능하다.

## 2. 점유 대기 예방
프로세스가 자원을 요청할 때는 다른 자원들을 가지고 있지 않다는 것을 보장해야 한다.  

1. 각 프로세스가 실행되기 전에 반드시 자신의 모든 자원을 요청하여 할당받게 하는 것이다.
2. 다른 대안으로는 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청하도록 하는 것이다. 추가 자원을 요청하려면 먼저 자신의 모든 자원을 방출해야 한다.  

두 방법 모두 단점이 존재한다.  

1. 자원 이용률이 낮다.  
많은 자원들이 할당된 후 오랫 동안 사용되지 않을 수 있다. 두번째 방법이라도 방출한 자원에 프로세스가 처리해야할 특정 데이터의 지속을 보장하지 못한다면 첫번째 방법을 사용해야 한다.
2. 기아 상태가 가능하다.  
프로세스가 실행전에 필요한 모든 자원들에 대해 대기할때, 최소 하나의 자원이라도 선점되어 있다면 무한정 대기한다.

## 3. 비선점 예방
한 프로세스가 자원을 할당받아 실행중이라도 다른 프로세스가 현재 프로세스를 중지시키고 자원을 강제적으로 뺏는다. 프로세스가 자원을 요청하면 그 자원이 사용가능한지 검사하고 할당한다. 자원 사용이 불가능하면, 그 자원들이 추가 자원을 기다리고 있는 다른 프로세스에게 할당되어 있는지를 검사한다. 만약 그렇다면 요청 프로세스는 자원을 선점한다. 그렇지 않다면 요청 프로세스는 대기한다.

## 4. 순환 대기 예방
모든 자원 타입들에게 전체적인 순서를 부여하여 각 프로세스가 순서대로 자원을 요청하도록 요구하게 한다. 프로세스는 초기에 자원 타입 R<sub>i</sub>의 인스턴스를 몇 개든지 요청할 수 있지만 그 후에는, 자원의 순서가 R<sub>j</sub> > R<sub>i</sub> 인 자원 타입 R<sub>j</sub>의 인스턴스만 요청할 수 있다.

# 5. 교착상태 회피 (Deadlock Avoidance)
교착상태 예방은 장치의 이용률을 저하하고 시스템 처리율을 감소한다. 각 프로세스의 요청과 방출에 대한 완전한 수서를 파악하고 미래의 발생가능한 교착상태를 피하기 위해 프로세스의 대기 여부를 결정한다. 이러한 결정을 위해서는 시스템은 가용 자원, 프로세스에 할당된 자원 그리고 요청되거나 방출될 자원을 고려해야 한다.  

가장 간단한 구현 방법으로는 각 프로세스가 필요한 자원의 최대 개수를 선언하도록 하는것이다. 이 알고리즘은 순환대기 상태를 막는다.  

## 5.1 안전 상태 (Safe State)
시스템 상태가 안전하다는 말은 시스템이 안전 순서(safe sequence)를 찾아 프로세스들이 요청하는 모든 자원을 교착상태를 야기시키지 않고 차례로 모두 할당해 줄 수 있다는 것을 뜻한다. 교착상태 회피의 기본원칙은 시스템의 상태가 항상 안전 상태를 유지 하는데 있다.    

역으로 교착상태에 있는 시스템은 불안전한 상태에 있다. 하지만 시스템 상태가 불안전하다고 해서 반드시 교착상태로 간다는 것은 아니다. 일단 불안전 상태가 되면 교착상태가 일어날 수도 있는 자원 요청을 막을 수 없다. 그러므로 시스템이 안전 상태에 머무는한 불안전 상태나 교착상태 모두를 예방할 수 있다.

###### &lt;안전, 불안전 상태>
![](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter7/7_06_StateSpaces.jpg)

## 5.2 자원 할당 그래프 알고리즘 (Resource-Allocation Graph Algorithm)
각 자원 타입마다 하나의 인스턴스를 갖고 있다면 자원 할당 그래프의 변형으로 회피가 가능하다. 자원을 할당해 할당간선이 생기기 전에 프로세스는 사용할 모든 자원들에 대한 예약 간선을 갖는다. 예약 간선을 추가한 할당 그래프에서 요청 간선이 할당 간선으로 변환돼도 사이클을 형성하지 않을때만 자원을 할당한다.  

###### &lt;예비 간선이 추가된 자원 할당 그래프>
![](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter7/7_07_DeadlockAvoidance.jpg)

###### &lt;불안전 상태의 자원 할당 그래프>
![](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter7/7_08_UnsafeState.jpg)

## 5.3. 은행원 알고리즘 (Banker's Algorithm)
은행원 알고리즘은 효율성은 다소 떨어지지만 각 자원 타입이 여러개의 인스턴스를 가지고 있어도 사용이 가능하다. 프로세스가 자원들을 요청하면 시스템은 그것을 들어주었을 때 시스템이 계속 안전 상태에 머무르게 되는지 판단하고 안전하게 된다면 그 요청을 들어준다.

# 6. 교착상태 탐지 (Deadlock Detection)
교착상태 예방이나 방지 알고리즘을 사용하지 않는다면, 교착상태가 발생하고 이런 환경에서는 반드시 다음 알고리즘을 지원해야 한다.  

* 교착상태가 발생했는지 결정하는 알고리즘
* 교착상태로부터 회복하는 알고리즘

## 6.1 각 자원 타입이 한 개씩 있는 경우
자원할당 그래프의 변형인 대기 그래프를 사용해 탐지 알고리즘을 정의한다. 프로세스의 요청 리소스를 점유하고 있는 프로세스에 대해 대기 관계를 갖는다. 대기 그래프가 사이클을 포함하는 경우에만 시스템에 교착상태가 존재한다.  

###### &lt;자원 할당 그래프 - 대기 그래프>
![](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter7/7_09_TwoGraphs.jpg)

## 6.2 각 자원 타입이 여러개인 경우

## 6.3 탐지 알고리즘 사용

# 7. 교착상태로부터 회복 (Recovery from Deadlock)
교착상태를 깨기 위해서는 한 개 이상의 프로세스를 중지시키거나 교착상태의 프로세스들로부터 자원을 선점하는 방법이 있다.  

## 7.1 프로세스 종료 (Process Termination)
종료 프로세스에게 할당되었던 모든 자원을 시스템이 회수한다.  

* 교착상태 프로세스를 모두 중지: 확실하게 교착상태의 사이클을 깨뜨리지만, 비용이 크다. 부분 계산의 결과들을 폐기해야 하고, 히우 다시 계산해야하기 때문이다.
* 교착상태가 제거될 때까지 한 프로세스 씩 중지: 각 프로세스가 중지될때마다 교착상태 탐지 알고리즘을 호출해 교착상태를 확인해 오버헤드를 유발한다.

프로세스를 중지 시키는 것은 프로세스의 처리 진행 과정을 확인해야 하며 어느 프로세스를 중지해야할지 결정해야하는 어려운 문제가 있다.  

## 7.2 자원 선점 (Resource preemption)
교착상태가 깨어질 떄까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 준다. 자원 선점 방식으로 교착상태로부터 회복하기 위해서는 다음 사항들을 고려해야 한다.  

1. 희생자 선택 (selection of a victim): 어느 자원과 프로세스가 선점될 것인가를 선택한다. 비용을 최소화 하기 위해 순서를 선정해야 한다.
2. 롤백 (rollback): 선점당하는 프로세스를 안전한 상태로 롤백시키고, 그 상태부터 다시 시작한다. 일반적으로 쉬운방법은 완전히 롤백시키는 것이다. 교착상태를 깨뜨릴 정도로 롤백시키면 더 효과적이지만 더많은 정보를 유지해야 한다.
3. 기아 상태 (starvation): 동일한 프로세스가 항상 희생자가 되지 않음을 보장해야한다. 일반적인 해결방법으로 롤백 횟수를 확인한다. 
