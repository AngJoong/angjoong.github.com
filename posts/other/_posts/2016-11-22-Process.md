---
layout: post
title:  "Process"
date:   2016-11-22 24:00:00 +0000
description:
tags: ['Process', 'OS']
author: "AngJoong"
---

초기 한 번에 하나의 프로그램만이 실행되던 컴퓨터에서, 메모리에 다수의 프로그램들이 적재되어 병행실행 되면서 프로세스의 개념을 낳았다.

# 1. 개념
실행 중인 프로그램  
다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련된 자원의 집합을 가진 능동적인 존재  

## 1.1 상태
프로세스는 실행되면서 그 상태가 변한다. 한 순간에 하나의 처리기상에는 오직 하나의 프로세스만이 실행된다.  

* **new**: 프로세스 생성 중이다.
* **running**: 명령어들이 실행되고 있다.
* **waiting**: 프로세스가 어떤 사건이 일어나기를 기다린다.
* **ready**: 처리기에 할당되기를 기다린다.
* **terminated**: 프로세스가 실행을 종료하였다.  

###### &lt;프로세스 상태도>
![](http://w3studentnotes.com/sites/default/files/Diagram_of_Process_State.png)

## 1.2 프로세스 제어 블록 (PCB: Process Control Block)
PCB는 특정 프로세스와 연관된 모든 정보의 저장소 역활을 한다.    

* **프로세스 상태**
* **프로그램 가운터**: 프로세스가 다음에 실행할 명령어의 주소
* **CPU 레지스터**: 여러 레지스터가 포함되며 상태 정보와 프로그램 카운터로부터 인터럽트 처리 후 프로세스가 중단점부터 올바르게 실행될 수 있게 한다.
* **CPU 스케줄링 정보**: 프로세스 우선순위, 스케쥴 큐에 대한 포인터 등
* **메모리 관리 정보**: 메모리 시스템에따른 기준(base), 한계(limit) 레지스터와 페이지 또는 세그먼트 테이블 정보
* **회계 정보**: 사용된 양, 시간, 프로세스 번호 등
* **입출력 상태 정보**: 프로세스에 할당된 입출력장치들과 열린 파일의 정보 목록

###### &lt;실행 프로세스 교환>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_04_ProcessSwitch.jpg)

## 1.3 스레드
프로세스 개념을 확장하여 한 프로세스가 여러 실행 스레드를 가질 수 있도록 하여 한순간에 하나 이상의 일을 실행할 수 있게 한다.  
PCB는 각 스레드에 관한 정보를 포함하도록 확장된다.  

# 2. 프로세스 스케줄링 (Process Scheduling)
비다중 프로그래밍 시스템에서는 입출력을 기다리는 동안 CPU가 유휴 상태가 되어 비효율적이다.  
다중 프로그래밍은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행 중이도록 한다.  
CPU 사용성을 최대화 하기 위해 여러 프로세스 중 하나의 프로세스를 선택하는 것을 스케줄링이라 한다.  

## 2.1 스케줄링 큐 (Scheduling Queues)
프로세스가 시스템에 들어오면, 잡 큐에 놓여진다.  
준비완료의 프로세스들은 준비완료(ready) 큐에 놓여진다.  
입출력 장치가 다른 프로세스들의 처리에 바쁠 경우 프로세스는 장치(device) 큐에 놓여진다.  
각 장치는 자신의 장치 큐를 가진다.  

###### &lt;준비완료 큐와 장치큐>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_05_Queues.jpg)


###### &lt;큐잉 도표>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_06_QueueingDiagram.jpg)

* 새로운 프로세스는 실행되기전까지 준비완료 큐에서 대기한다.  
* 프로세스가 입출력을 요청하여 입출력 큐에 들어갈 수 있다.  
* 인터럽트 결과에 따라 CPU로부터 제거되어 준비완료 큐로 돌아갈 수 있다.

## 2.2 스케줄러 (Schedulers)
프로세스를 스케줄링 하기 위해서 운영체제는 큐에서 프로세스들을 선택해야한다.  
일괄처리 시스템은 실행될 수 있는 것보다 더 많은 프로세스들이 제출되면 실행할때까지 대용량 메모리에 보관한다.  
장기 스케줄러(잡 스케줄러)는 이 풀에서 프로세스를 선택해 메모리에 적재한다.  
단기 스케줄러(CPU 스케줄러)는 실행준비가 완료된 프로세스 중 하나에게 CPU를 할당한다.

### 2.2.1 장기 스케줄러
* CPU를 위해 새로운 프로세스를 빈번하게 할당한다.  
* 프로세스는 입출력대기를 위해 적게는 몇 밀리초만에 대기 상태에 들어간다.  

### 2.2.2 장기 스케줄러
* 시스템에서 새로운 프로세스를 생성하는 간격은 상대적으로 자주 일어나지 않는다.  
* 다중 프로그래밍 정도(메모리에 있는 프로세스 수)를 제어한다.  
* 프로세스 생성률과 프로세스 이탈률이 같아야 다중 프로그래밍의 정도가 안정적이다.  
* 프로세스가 이탈할때에만 작동한다.  
* 입출력 중심, CPU 중심 프로세스의 비율을 적절하게 선택해야한다.  

장기스케줄러가 없는 시스템은 모든 프로세스를 단기 스케줄러를 위해 메모리에 넣는다.  
안정성은 사용자들의 자체 조정 본능에 의존한다.  
일부 운영체제는 중기 스케줄러를 도입하여 다중 프로그래밍 정도를 낮추는 스와핑 기법을 사용하기도 한다.  

## 2.3 컨텍스트 교환 (Context Switch)
인터럽트가 발생하면 운영체제는 CPU의 현재 작업을 멈추고 커널 루틴을 실행 한다.  
인터럽트 처리가 끝나면 실행중이던 프로세스를 복구해야 하는데 이를 위해 컨텍스트를 저장 한다.  
컨텍스트는 CPU 레지스터의 값, 프로세스 상태, 메모리 정보 등을 포함하며 PCB에 저장된다.   
프로세스를 교환하기 위해 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복구하는 것을 컨텍스트 스위칭이라 한다.  
컨택스트 스위칭 동안 시스템은 어떠한 작업도 할 수 없어 오버헤드가 발생한다.  

# 3. 프로세스에 대한 연산 (Operation on Processes)
프로세스는 동적으로 생성되고, 제거될 수 있다. 그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

## 3.1 프로세스 생성 (Process Creation)
프로세스는 실행 도중에 프로세스 생성 시스템 호출을 통해서 여러 개의 새로운 프로세스들을 생성할 수 있다. 생성하는 프로세스를 부모, 새로운 프로세스를 자식이라고 한다. 자식 프로세스들은 다시 자식 프로세스를 생성할 수 있으며, 프로세스 트리를 형성한다.

###### &lt;프로세스 트리> - sched는 모든 사용자 프로세스의 부모 역활을 하는 init를 생성한다
![](http://cfile27.uf.tistory.com/image/0126654050F642E7117090)

보통 프로세스는 식별자(PID)에 의해 구분된다. 프로세스는 자신의 태스크를 달성하기 위해 자원을 필요로 한다. 자식프로세스 운영체제에서 자원을 얻거나, 부모프로세스 자원을 공유 받는다.

###### &lt;프로세스 생성>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_10_ProcessCreation.jpg)

## 3.2 프로세스 종료 (Process Termination)
프로세스 자신이 exit 시스템 호출을 사용하여 운영체제에 제거 요청을 하거나 PID를 통해 부모가 자식 프로세스를 제거할 수 있다. 부모 프로세스 종료시에는 init 프로세스를 새로운 부모로 지정받는다. 제거시 부모 프로세스에게 상태 값을 반환(wait 시스템 함수 통해)할 수 있으며 운영체제에 모든 자원을 반환한다.

# 4. 프로세스간 통신 (Interprocess Communication)
