---
layout: post
title:  "Process"
date:   2016-11-22 24:00:00 +0000
description:
tags: ['Process', 'OS']
author: "AngJoong"
---

초기 한 번에 하나의 프로그램만이 실행되던 컴퓨터에서, 메모리에 다수의 프로그램들이 적재되어 병행실행 되면서 프로세스의 개념을 낳았다.

# 1. 개념
실행 중인 프로그램  
다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련된 자원의 집합을 가진 능동적인 존재  

## 1.1 상태
프로세스는 실행되면서 그 상태가 변한다. 한 순간에 하나의 처리기상에는 오직 하나의 프로세스만이 실행된다.  

* **new**: 프로세스 생성 중이다.
* **running**: 명령어들이 실행되고 있다.
* **waiting**: 프로세스가 어떤 사건이 일어나기를 기다린다.
* **ready**: 처리기에 할당되기를 기다린다.
* **terminated**: 프로세스가 실행을 종료하였다.  

###### &lt;프로세스 상태도>
![](http://w3studentnotes.com/sites/default/files/Diagram_of_Process_State.png)

## 1.2 프로세스 제어 블록 (PCB: Process Control Block)
PCB는 특정 프로세스와 연관된 모든 정보의 저장소 역활을 한다.    

* **프로세스 상태**
* **프로그램 가운터**: 프로세스가 다음에 실행할 명령어의 주소
* **CPU 레지스터**: 여러 레지스터가 포함되며 상태 정보와 프로그램 카운터로부터 인터럽트 처리 후 프로세스가 중단점부터 올바르게 실행될 수 있게 한다.
* **CPU 스케줄링 정보**: 프로세스 우선순위, 스케쥴 큐에 대한 포인터 등
* **메모리 관리 정보**: 메모리 시스템에따른 기준(base), 한계(limit) 레지스터와 페이지 또는 세그먼트 테이블 정보
* **회계 정보**: 사용된 양, 시간, 프로세스 번호 등
* **입출력 상태 정보**: 프로세스에 할당된 입출력장치들과 열린 파일의 정보 목록

###### &lt;실행 프로세스 교환>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_04_ProcessSwitch.jpg)

## 1.3 스레드
프로세스 개념을 확장하여 한 프로세스가 여러 실행 스레드를 가질 수 있도록 하여 한순간에 하나 이상의 일을 실행할 수 있게 한다.  
PCB는 각 스레드에 관한 정보를 포함하도록 확장된다.  

# 2. 프로세스 스케줄링 (Process Scheduling)
비다중 프로그래밍 시스템에서는 입출력을 기다리는 동안 CPU가 유휴 상태가 되어 비효율적이다.  
다중 프로그래밍은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행 중이도록 한다.  
CPU 사용성을 최대화 하기 위해 여러 프로세스 중 하나의 프로세스를 선택하는 것을 스케줄링이라 한다.  

## 2.1 스케줄링 큐 (Scheduling Queues)
프로세스가 시스템에 들어오면, 잡 큐에 놓여진다.  
준비완료의 프로세스들은 준비완료(ready) 큐에 놓여진다.  
입출력 장치가 다른 프로세스들의 처리에 바쁠 경우 프로세스는 장치(device) 큐에 놓여진다.  
각 장치는 자신의 장치 큐를 가진다.  

###### &lt;준비완료 큐와 장치큐>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_05_Queues.jpg)

###### &lt;큐잉 도표>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_06_QueueingDiagram.jpg)

* 새로운 프로세스는 실행되기전까지 준비완료 큐에서 대기한다.  
* 프로세스가 입출력을 요청하여 입출력 큐에 들어갈 수 있다.  
* 인터럽트 결과에 따라 CPU로부터 제거되어 준비완료 큐로 돌아갈 수 있다.

## 2.2 스케줄러 (Schedulers)
프로세스를 스케줄링 하기 위해서 운영체제는 큐에서 프로세스들을 선택해야한다.  
일괄처리 시스템은 실행될 수 있는 것보다 더 많은 프로세스들이 제출되면 실행할때까지 대용량 메모리에 보관한다.  
장기 스케줄러(잡 스케줄러)는 이 풀에서 프로세스를 선택해 메모리에 적재한다.  
단기 스케줄러(CPU 스케줄러)는 실행준비가 완료된 프로세스 중 하나에게 CPU를 할당한다.

### 2.2.1 단기 스케줄러
* CPU를 위해 새로운 프로세스를 빈번하게 할당한다.  
* 프로세스는 입출력대기를 위해 적게는 몇 밀리초만에 대기 상태에 들어간다.  

### 2.2.2 장기 스케줄러
* 시스템에서 새로운 프로세스를 생성하는 간격은 상대적으로 자주 일어나지 않는다.  
* 다중 프로그래밍 정도(메모리에 있는 프로세스 수)를 제어한다.  
* 프로세스 생성률과 프로세스 이탈률이 같아야 다중 프로그래밍의 정도가 안정적이다.  
* 프로세스가 이탈할때에만 작동한다.  
* 입출력 중심, CPU 중심 프로세스의 비율을 적절하게 선택해야한다.  

장기스케줄러가 없는 시스템은 모든 프로세스를 단기 스케줄러를 위해 메모리에 넣는다.  
안정성은 사용자들의 자체 조정 본능에 의존한다.  
일부 운영체제는 중기 스케줄러를 도입하여 다중 프로그래밍 정도를 낮추는 스와핑 기법을 사용하기도 한다.  

## 2.3 컨텍스트 교환 (Context Switch)
인터럽트가 발생하면 운영체제는 CPU의 현재 작업을 멈추고 커널 루틴을 실행 한다.  
인터럽트 처리가 끝나면 실행중이던 프로세스를 복구해야 하는데 이를 위해 컨텍스트를 저장 한다.  
컨텍스트는 CPU 레지스터의 값, 프로세스 상태, 메모리 정보 등을 포함하며 PCB에 저장된다.   
프로세스를 교환하기 위해 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복구하는 것을 컨텍스트 스위칭이라 한다.  
컨택스트 스위칭 동안 시스템은 어떠한 작업도 할 수 없어 오버헤드가 발생한다.  

# 3. 프로세스에 대한 연산 (Operation on Processes)
프로세스는 동적으로 생성되고, 제거될 수 있다. 그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

## 3.1 프로세스 생성 (Process Creation)
프로세스는 실행 도중에 프로세스 생성 시스템 호출을 통해서 여러 개의 새로운 프로세스들을 생성할 수 있다. 생성하는 프로세스를 부모, 새로운 프로세스를 자식이라고 한다. 자식 프로세스들은 다시 자식 프로세스를 생성할 수 있으며, 프로세스 트리를 형성한다.

###### &lt;프로세스 트리 - sched는 모든 사용자 프로세스의 부모 역활을 하는 init를 생성한다>
![](http://cfile27.uf.tistory.com/image/0126654050F642E7117090)

보통 프로세스는 식별자(PID)에 의해 구분된다. 프로세스는 자신의 태스크를 달성하기 위해 자원을 필요로 한다. 자식프로세스 운영체제에서 자원을 얻거나, 부모프로세스 자원을 공유 받는다.

###### &lt;프로세스 생성>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_10_ProcessCreation.jpg)

## 3.2 프로세스 종료 (Process Termination)
프로세스 자신이 exit 시스템 호출을 사용하여 운영체제에 제거 요청을 하거나 PID를 통해 부모가 자식 프로세스를 제거할 수 있다. 부모 프로세스 종료시에는 init 프로세스를 새로운 부모로 지정받는다. 제거시 부모 프로세스에게 상태 값을 반환(wait 시스템 함수 통해)할 수 있으며 운영체제에 모든 자원을 반환한다.

# 4. 프로세스간 통신 (Interprocess Communication)
운영체제 내에서 다른 프로세스들과 영향을 주고 받는 협력적인 프로세스들에는 몇가지 장점이 있다.  

* 정보 공유 (information sharing): 여러 사용자가 하나의 정보에 병행적인 접근 환경 제공  
* 계산 가속화 (computation speedup): 특정 태스크를 서브태스크로 나눠 병렬로 처리한다.  
* 모듈성 (modularity): 기능을 별도의 프로세스 또는 스레드로 나누어 모듈 형태로 시스템을 구성한다.
* 편의성 (convenience): 개별 사용자들이 병렬적으로 여러 프로세스를 처리하기 원할때  

협렵적 프로세스들은 정보를 교환할 수 있는 프로세스간 통신(IPC: interprocess communication) 기법을 사용한다. 프로세스 통신 기법으로는 공유 메모리, 메시지 전달 모델이 있다.  

공유 메모리 모델은 프로세스간 공유되는 메모리 영역을 구축하고 그 영역에 데이터를 읽고 쓴다. 메시지 전달 모델은 프로세스간 교환되는 메시지를 통해 이루어 진다.

###### &lt;IPC 모델 - 공유 메모리 & 메시지 전달>
![](https://camo.githubusercontent.com/4e9a28ec895d2401054c4d618d91deea38e592da/687474703a2f2f7777772e65656e61647570726174696268612e6e65742f70726174696268612f656e67696e656572696e672f696d616765732f636f6e74656e745f706963732f6f735f7549495f696d6167392e6a7067)

## 4.1 공유 메모리 (shared memory)
통신하는 프로세스들이 공유 메모리영역을 구축해야 한다. 공유 메모리세그먼트를 생성하는 프로세스의 주소 공간에 위치하며 이 공유 메모리 세그먼트를 사용하려는 프로세스들은 자신의 주소 공간에 이 세그먼트를 추가해야 한다.  

공유 영역에 데이터를 읽고 씀으로써 정보를 교환한다. 데이터의 형식과 위치는 프로세스들이 결정하며 동시에 동일한 위치에 쓰지 않는다는 것을 보장해야 한다. 생산자-소비자 모델을 생각하면 쉽게이해할 수 있다.

## 4.2 메시지 전달 (message passing)
프로세스들이 네트워크에 의해 연결된 분산 환경에서 유용하다. 시스템 호출을 사용해서 구현되므로 커널 간섭에 의한 오버헤드가 발생한다.  

프로세스간 통신 연결(communication link)가 설정되어 메시지를 주고 받아야 하며 다음과 같은 논리적 구현방식이 있다.  

* 직접, 간접 통신
* 동기식, 비동기식 통신
* 자동, 명시적 버퍼링

### 4.2.1 네이밍 (Naming)
프로세스간 서로를 가리킬 수 있는 방법이 있어야 직, 간접적인 통신이 가능하다.  

#### 직접 통신
송, 수신자의 이름을 명시해 직접통신이 가능하다. 대칭 형식은 두 프로세스간 하나의 연결이 생성된다.  

* send(P, message) - P에게 message 전송
* receive(Q, message) - Q에게 message 전송

송신자만 수신자의 이름을 지명하는 비대칭 형식도 사용가능하다.  

* send(P, message) - P에게 message 전송
* receive(id, message) - 임의의 프로세스로부터 message와 프로세스의 이름인 id 수신  

직접 통신은 프로세스를 정확히 지정함으로써 모듈화를 제한하는 단점이 있다. 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정부분의 수정이 동반되기 때문이다.  

#### 간접 통신
메시지들이 메일박스(mailbox) 또는 포트로 간접 송, 수신 된다.  

* send(A, message) - 메일박스 A에게 message 송신
* receive(A, message) - 메일박스 A로부터 message 수신

프로세스간 연결은 공유 메일박스를 통해 구축된다. 두개 이상의 프로세스가 연결될 수 있고 서로 다른 연결마다 하나의 메일박스가 할당된다. 하나의 메일박스에 3개 이상의 프로세스가 연결되면 메일박스 소유자(메일박스 생성자)가 독점적으로 메시지를 수신하거나 라운드 로빈과 같은 수신자 선택 알고리즘을 사용하여 메시지를 수신한다.

### 4.2.2 동기화 (Synchronization)
프로세스간 통신은 send와 receive 프리미티브에 대한 호출을 통해 발생한다. 프리미티브 구현에는 여러 설계 옵션이 존재하며 메시지 전달에는 블락킹, 논블락킹(동기, 비동기) 방식이 있다.  

* 블락킹 송신: 송신 프로세스가 메시지가 수신될때까지 블락된다.
* 논블락킹 송신: 송신 프로세스가 메시지를 보내고 작업을 재시작 한다.
* 블락킹 수신: 메시지가 이용가능할 떄까지 수신 프로세스가 블락된다.
* 논블락킹 수신: 수신하는 프로세스가 유효한 메세지 또는 널을 받는다.  

### 4.2.3 버퍼링 (Buffering)
직, 간접 통신에 상관 없이 교환되는 메시지는 임시 큐에 들어 간다. 이러한 큐를 구현하는 방식은 세 가지가 있다.  

* 무용량 (zero capacity): 큐의 최대 길이가 0이다. 큐에 대기하는 메시지를 가질 수 없다. 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.  
* 유한 용량 (bounded capacity): 유한한 길이를 가진다. 새로운 메시지는 큐가 만원이 아니라면, 큐에 놓이며 송신자는 대기 없이 실행을 계속한다. 단, 큐가 만원이면 가용공간이 생길 때 까지 블락된다.  
* 무한 용량 (unbounded capacity): 무한한 길이를 갖는다. 메시지는 얼마든지 큐 안에서 대기할 수 있어, 송신자 블락이 발생하지 않는다.  

# 5. 클라이언트 서버 환경에서 통신 (Communication in Client-Server Systems)
공유 메모리와 메시지 전달 기법을 사용하여 프로세스간 통신, 클라이언트-서버간 통신 하는 방법 외, 클라이언트-서버 시스템에서 사용할 수 있는 소켓, 원격 프로시저 호출, 파이프에 대해 설명한다.  

## 5.1 소켓 (Socket)
소켓은 통신의 극점(endpoint)을 뜻한다. 프로세스가 네트워크 상에서 통신을 하려면 총 두 개의 소켓이 필요하다. 각 소켓은 IP와 포트 번호로 구별한다. 두 호스트 사이에 패킷들이 오갈 때 그 패킷들은 목적지 포트에 따라 적절한 프로세스로 전달된다. 모든 연결은 유일한 소켓 쌍으로 구성되어야 한다.  

###### &lt;소켓 통신>
![](/_data/other/Process-8.gif)

소켓 통신은 분산된 프로세스들 간에 널리 사용되고 효율적이지만 저수준이다. 구조화되지 않은 바이트 스트림만을 통신하기 때문이다. 바이트 스트림 데이터를 구조화하여 해석하는 것은 클라이언트와 서버의 책임이다.  

## 5.2 원격 프로시저 호출 (RPC: Remote Procedure Calls)
프로세스들이 서로 다른 시스템에서 실행되는 환경에서 원격 서비스를 제공하기 위해서는 메시지 기반 통신을 해야 한다. IPC방식과는 다르게 전달되는 메시지는 구조화 되어 있다. 각 메시지에는 RPC 디먼의 주소가 지정되어 있고 실행될 함수의 식별자, 매개변수를 포함한다. 디먼을 특정 포트에 등록시키고 원격 시스템이 서버의 포트로 RPC 메시지를 보내면 필요한 정보를 응답 메시지 형태로 받는다.

RPC는 로컬 프로시저를 호출하는 것처럼 원격 호스트의 프로시저를 호출한다. RPC 시스템은 클라이언트 쪽에 스텁(stub)을 제공하여 통신한다. 클라이언트가 원격 프로시저를 호출하면 RPC는 그에 대응하는 스텁을 호출하고 원격 프로시저가 필요로 하는 매개변수를 건네준다. 그러면 스텁이 원격 서버의 포트를찾고 매개변수를 정돈(marshall)한다. 매개변수 정돈이란 프로시저에게 갈 매개변수를 네트워크로 전송하기 위해 적적한 형태로 재구성한다. 그 후 스텁은 매시지 전달 기법을 사용하여 서버에게 메시지를 전송한다. 이에 대응되는 스텁이 서버에도 존재하여 서버 측 스텁이 메시지를 수신한 후 적절한 서버의 프로시저를 호출한다. 필요한 경우 반환 값들도 동일한 방식으로 되돌려 준다.  

RPC를 구현하려면 데이터 표현 방식, 호출 보장, 네트워크 통신등을 고려해야 한다.  

###### &lt;RPC>
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_23_RPC.jpg)

### 5.2.2 데이터 표현 방식
클라이언트와 서버의 데이터 표현 방식이 다를 경우를 대비해 기종 중립적인 데이터 표현 방식을 정의한다. 이러한 표현 방식 중 하나가 XDR(external data representation)이다.  

클라이언트 측에서는 데이터를 보내기 전 매개변수 정돈 작업의 일황으로 전송할 데이터를 XDR 형태로 바꾸어서 보낸다. 수신측 기계에서는 XDR 데이터를 받으면 매개변수를 풀어내면서 자기 기종의 형태로 데이터를 바꾼 후 서버에게로 넘겨준다.  

### 5.2.3 호출의 의미 (semantic)
지역 프로시저 호출의 경우 근단적인 경우에만 실패하지만, RPC 경우 네트워크 오류 때문에 실패할 수도 있고, 메시지가 중복되어 호출이 여러 번 될 수도 있다. 그래서 프로시저 호출이 '정확히 한번' 되도록 보장해야한다.  

#### 최대한 한번
각 메시지에 타임스탬프를 매기는 것으로 보장할 수 잇다. 서버는 이미 처리한 모든 메시지의 타임스탬프 기록을 갖거나 중복된 메시지를 검사해 낼 수 있을 만큼의 기록을 가져야 한다. 기록된 타임스탬프를 가진 메시지가 도착하면 그 메시지는 무시된다.  

#### 정확히 한번
서버가 요청을 받지 못하는 위험을 제거해야한다. 일단 '최대한 한번' 을 구현하고 추가로 RPC 요청이 수신되었고 실행됐다는 응낙(acknowledgement) 메시지를 보내야만 한다. 네트워킹에서 ACK는 일반적이며, 클라이언트는 해당 호출에 대한 ACK를 받을 떄까지 주기적으로 각 RPC 호출을 재전송해야 한다.  

### 5.2.4 클라이언트-서버 통신
클라이언트와 서버의 포트를 바인딩해야 한다. 이를 위해 고정된 포트 주소를 미리 정해 놓거나 동적 바인딩 해야 한다.

#### 고정된 포트 주소
컴파일할 떄 RPC에게 고정된 포트 번호를 주고 컴파일 이후에는 서버가 포트 번호를 임의로 바꿀 수 없다.  

#### 동적 바인딩
랑데부 방시에 의해 동적으로 바인딩하는 방법. 보통 운영체제는 미리 정해져 있는 고정 RPC 포트를 통해 랑데부용 디먼(matchmaker)을 제공한다. 클라이언트는 자신이 실행하길 원하는 RPC 이름을 담고 있는 메시지를 랑데부 디먼에게 보내고, RPC이름에 대응하는 포트 번호가 무엇인지 알려달라고 요청한다. 그러면 포트 번호가 클라이언트에게 반환되고, 클라이언트는 그 포트 번호로 RPC 요청을 계속 보낸다.

## 5.3 파이프 (Pipes)
파이프는 두 프로세스가 통신할 수 있게 하는 전달자다. 간단한 통신 방법이지만 몇가지 문제를 고려해봐야 한다.

* 단방향 통신 Vs 양방향 통신
* 양방향 통신인 경우 반이중(half duplex)방식인가, 전이중(full duplex)방식인가.
* 통신 프로세스간 부모-자식 관계가 있는가
* 동일 디바이스간 통신인가 네트워킹 통신인가

###### &lt;Pipe>
![](https://4.bp.blogspot.com/-zqyd5lEMtC4/Vav75hxTGVI/AAAAAAAAcsM/BzmzHN7Mot0/s640/pipes.PNG)

### 5.3.1 보통의 파이프
생산자는 한 종단에 쓰고, 소비자는 다른 종단에서 읽으며 오직 단방형 통신만이 가능하다. 양방향 통신을 위해서는 두개의 파이프를 사용해야 한다.  

보통의 파이프는 생성한 프로세스 외에는 접근할 수 없다. 따라서 부모로부터 열린 파일을 상속받는 자식프로세스와만 통신이 가능하다. 사용하지 않는 종단은 반드시 닫아야 하며 닫힌 종단의 반대편 종단은 EOF를 받는다.  

### 5.3.2 지명 파이프 (Named Pipes)
보통의 파이프는 간단한 통신 기법만 제공하며 프로세스가 종료하면 파이프는 없어지게 된다. 지명 파이프는 이와 달리 양방향 통신이 가능하고 모-자식 관계도 필요로 하지 않는다. 지명 파이프가 구축되면 어러 프로세스들이 이를 사용하여 통신할 수 있다. 때문에 프로세스가 종료하더라도 지명 파이프는 계속존재하게 된다.
