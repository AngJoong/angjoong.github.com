---
layout: post
title:  "Multi Thread Programming"
date:   2016-12-02 19:00:00 +0000
description:
tags: ['Thread', 'OS']
author: "AngJoong"
---

# 1. Overview
스레드는 CPU 이용의 기본 단위이다. 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.  

<br/>
**&lt;단일 및 다중 스레드 프로세스>**
<img  class="aligncenter" src="http://postfiles11.naver.net/20150417_202/three_letter_1429254488468egL0u_JPEG/4_01_ThreadDiagram.jpg?type=w2">
<br/>
<br/>

## 1.1 동기
웹 서버가 전통적인 단일 스레드 프로세스로 작동한다면, 자신의 단일 프로세스로 **한 번에 하나의 클라이언트만 서비스할 수 있게 되어** 클라이언트는 자신의 요구가 서비스되기까지 매우 긴 시간을 기다려야 한다.  

하나의 해결책은 서버에게 요청이 들어오면, 프로세스는 그 요청을 실행할 별도의 프로세스를 생성하는 것이다. 하지만 새 프로세스가 해야 할 일이 기존 프로세스와 동일한데 프로세스 생성 오버헤드를 감수할 필요가 없다.  

대부분의 경우 **프로세스 안에 여러 스레드를 만들어 나가는 것이 더 효율 적이다.**  

<br/>
**&lt;다중 스레드화 된 서버 구조 - 요청 수신과 처리 스레드 분리>**
<img class="aligncenter" src="http://postfiles15.naver.net/20150417_286/three_letter_142925454398959i6U_JPEG/4_02_MultithreadedArchitecture.jpg?type=w2">
<br/>
<br/>

## 1.2 장점
1. 응답성 (responsiveness): 응용 프로그램의 일부분이 봉쇄되거나, 응용 프로그램이 긴 작업을 실행하더라도 **프로그램의 실행이 계속되는 것을 허용함** 으로써 사용자에 대한 응답성을 증가시킨다.  

2. 자원 공유 (resource sharing): 프로세스는 공유 메모리 또는 메시지 전달 기법을 통해서만 자원을 공유할 수 있다. 그러나 **스레드는 자동적으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다.**  

3. 경제성 (economy): 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. **스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥을 교환하는 것이 보다 더 경제적이다.**

4. 규모 가변성 (scalability): **다중처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 실행될 수 있기 때문이다.**  

## 1.3 다중 코어 프로그래밍
다중 스레드 프로그래밍은 다중 코어를 더 효율적으로 사용할 수 있고 병행성을 더 향상시킬 수 있는 기법을 제공한다.  

하나의 코어는 한번에 오직 하나의 스레드만 실행할 수 있기 때문에 코어가 한 개인 시스템 상에서 병행성은 단순히 스레드의 실행이 시간에 따라 교대로 실행된다는 것을 의미한다.  

<br/>
**&lt;단일 코어 시스템에서의 병행 실행>**
<img class="aligncenter" src="http://postfiles16.naver.net/20150417_95/three_letter_1429254600113YiEFV_JPEG/4_03_ConcurrentSingleCore.jpg?type=w2">
<br/>
<br/>

그러나, 여러 코어를 가진 시스템에서는 시스템이 개별 스레드를 각 콕어에 배정할 수 있기 때문에 병행성은 스레드들이 병렬적으로 실행될 수 있다는 것을 뜻한다.  

<br/>
**&lt;다중 코어 시스템에서의 병행 실행>**
<img class="aligncenter" src="http://postfiles3.naver.net/20150417_290/three_letter_1429254600234Mjt6D_JPEG/4_04_ParralelMulticore.jpg?type=w2">
<br/>
<br/>

일반적으로 다중코어 시스템 상에서 프로그래밍을 하기 위해서는 5개의 극복해야 할 도전 과제가 있다.  

1. 작업 나누기 (dividing activities): 각 태스크가 개별 코어 상에서 병렬적으로 실행될 수 있도록 응용을 독립된 태스크로 나누는 작업  

2. 균형 (balance): 각 태스크가 전체 작업에 균등한 기여도를 가지도록 나누는것  

3. 데이터 분리 (data spliting): 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나눈다  

4. 데이터 종속성 (data dependency): 둘 이상의 태스크 사이에 종속성이 없는지 검토해야 한다. 데이터가 종속적인 경우 적절한 동기화가 필요하다.  

5. 시험 및 디버깅 (testing and debugging): 단일 스레드에서 시험하고 디버깅하는것 보다 어렵다.  

# 2. 다중 스레드 모델 (Multithreading Models)
스레드를 위한 지원 및 관리는 사용자 스레드(user threads)는 사용자 수준에서, 커널 스레드(kernel threads)는 커널 수준에서 제공된다.  

각 수준에서 관리되는 사용자 스레드와 커널 스레드에는 연관 관계가 필요하다.  

## 2.1 다-대-일 모델 (Many-to-One Model)
다수의 사용자 수준 스레드를 하나의 커널 스레드에 사상한다. 시스템 호출에 의한 커널 접근이 하나의 커널 스레드에서만 가능하기 때문에 **다중 스레드가 다중 처리기에서 수행되어도 병렬로 작동할 수 없다.**  

<br/>
**&lt;다-대-일 모델>**  
<img class="aligncenter" src="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_05_ManyToOne.jpg">
<br/>
<br/>

## 2.2 일-대-일 모델 (One-to-One Model)
각 사용자 스레드를 각각의 커널 스레드에 사상한다. **하나의 스레드가 봉쇄적 시스템 호출을 하더라도 다른 스레드가 실행될 수 있다.** 다-대-일 모델보다 더 높은 병렬성을 제공한다. 단, 사용자 스레드마다 커널 스레드를 생성하는 **오버헤드가 발생할 수 있어 시스템에의해 지원되는 스레드의 수를 제한한다.**  

<br/>
**&lt;일-대-일 모델>**  
<img class="aligncenter" src="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_06_OneToOne.jpg">
<br/>
<br/>

## 2.3 다-대-다 모델 (Many-to-Many Model)
여러 개의 사용자 수준 스레드를 그보다 작거나 같은 수의 커널 스레드로 다중화한다. **개발자는 필요한 만큼 많은 사용자 수준의 스레드를 생성할 수 있다. 또, 커널 스레드가 다중 처리기에서 병렬로 실핼될 수도 있다.** 사용자 스레드가 하나의 커널 스레드에 종속되는 두 수준 모델(two-level model)을 사용하기도 한다.  

<br/>
**&lt;다-대-다 모델 & 두 수준 모델>**  
<img class="aligncenter" src="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_08_TwoLevel.jpg">
<br/>
<br/>

# 3. 스레드 라이브러리 (Thread Library)
프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공한다. 커널의 지원없이 완전히 사용자 공간에서만 라이브러리를 제공하거나, 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하기도 한다.  

# 4. 스레드와 관련된 문제들 (Threading Issues)

## 4.1 Fork() 및 Exec() 시스템 호출
fork()를 호출하면 새로운 프로세스가 **모든 스레드를 복제해야 하는가, 한개의 스레드만 복제하면되는가 의문이 생긴다.** 몇몇 UNIX 들은 두 가지 버전 모두를 제공한다.  

exec()는 메개변수로 지정된 프로그램이 프로세스를 대체한다. 보통 이럴경우 fork()는 하나의 스레드만 복사해주는게 효과적이다. 그렇지 않는 경우 새 프로세스는 모든 프로세스를 복제해야 한다.

## 4.2 취소 (Cancellation)
**스레드가 끝난기 전에 강제 종료시키는 작업이다.** 여러 스레드가 데이터베이스를 병렬로 검색하고 있다가 한 스레드가 결과를 찾았다면 나머지 스레드들은 취소되어도 된다.  

**취소되어야 할 스레드를 목적 스레드(target thread)** 라고 부른다.
1. 비동기식 취소 (asynchronous cancellation): 한 스레드가 목적 스레드를 **즉시 강제 종료 한다.**
2. 지연 취소 (deferred cancellation): 목적 스레드가 **자신이 강제 종료되어야 하는지 주기적으로 확인한다.**

스레드 취소를 어렵게 만드는 것은 취소 스레드들에게 할당된 자원과 및 공유 자원이다. 비동기식 취소의 경우 위와 같은 문제를 해결하기 어렵다. 반면, 지연 취소의 경우 목적 스레드가 취소점(cancellation potint: 자신이 취소되어도 안전한 시점) 에서만 취소 여부를 검사한다.  

## 4.3 신호 처리 (Signal Handling)
신호는 UNIX에서 **프로세스에게 어떤 사건이 일어났음을 알려주기 위해 사용한다.** 모든 신호는 다음과 같은 특징을 갖는다.

1. 신호는 특정 사건이 일어나야 생성된다.
2. 신호가 생성되면 프로세스에게 전달된다.
3. 신호가 전달되면 반드시 처리되어야 한다.

신호는 사건의 근원지나 이유에 따라 동기 또는 비동기식으로 전달된다. **동기식 신호는 신호를 발생시킨 연산을 실행한 프로세스에게 전달된다.** (ex. Division by zero) **비동기식 신호는 실행 중인 프로세스의 외부로부터 신호가 발생된다.** (ex. ctr + c)  

모든 신호는 둘 중 하나의 처리기에 의해 처리된다.

1. 디폴트 신호 처리기
2. 사용자 정의 신호 처리기

ㅇ
